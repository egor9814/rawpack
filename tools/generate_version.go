package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

type versionKind byte

const (
	noVersion versionKind = iota
	commitHashVersion
	semverVersion
)

func getRawVersion() (versionKind, string, error) {
	cmd := exec.Command("git", "describe", "--tags", "--exact-match")
	out, err := cmd.Output()
	if err == nil {
		return semverVersion, strings.TrimSpace(string(out)), nil
	}
	cmd = exec.Command("git", "rev-parse", "HEAD")
	out, err = cmd.Output()
	if err == nil {
		return commitHashVersion, strings.TrimSpace(string(out)), nil
	}
	return noVersion, "", nil
}

func main() {
	k, s, err := getRawVersion()
	if err != nil {
		log.Fatal(err)
	}
	prefix, major, minor, patch, suffix := "", "0", "0", "0", ""

	switch k {
	default:
		panic("unknown version kind")

	case noVersion:
		fmt.Println("warning: no version")

	case commitHashVersion:
		prefix = "no-tag-"
		suffix = "-" + s

	case semverVersion:
		re, err := regexp.Compile(`^(.*)(\d+)\.(\d+)\.(\d+)(.*)$`)
		if err != nil {
			log.Fatal(err)
		}
		match := re.FindStringSubmatch(s)
		if len(match) != 6 {
			log.Fatal("tag is not semver")
		}
		prefix = match[1]
		major = strings.TrimLeft(match[2], "0")
		minor = strings.TrimLeft(match[3], "0")
		patch = strings.TrimLeft(match[4], "0")
		suffix = match[5]
	}

	template := `// auto-generated by tools/generate_version.go
package main

func init() {
	Version.Prefix = "%s"
	Version.Major = %s
	Version.Minor = %s
	Version.Patch = %s
	Version.Suffix = "%s"
}
`
	template = fmt.Sprintf(template, prefix, major, minor, patch, suffix)

	if err := os.WriteFile("version_init.go", []byte(template), 0644); err != nil {
		log.Fatal(err)
	}
}
